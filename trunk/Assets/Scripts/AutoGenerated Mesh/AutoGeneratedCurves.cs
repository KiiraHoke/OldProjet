using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;

public class AutoGeneratedCurves  : MonoBehaviour{
    // CURVES
    public Color couleur = Color.blue;
    public int nodeCount = 0;
    public List<GameObject> nodes = new List<GameObject>();
    private Vector3[] positions = new List<Vector3>().ToArray();
    // GUI
    private GUIStyle style;
    // Balle - placement
    public GameObject balle;
    public Rigidbody balleRigidBody;
    public float percentage = 0.0f;
    // Balle - Automove
    public bool autoMove = true;
    public float vitesse = 5.0f;
    public Vector3 vitesses = new Vector3(2.0f, 5.0f, 9.0f);
    public float acceleration = 2.0f;
    public KeyCode KeyAcceleration = KeyCode.UpArrow;
    public KeyCode KeyDeceleration = KeyCode.DownArrow;
        //public KeyCode accelerationKey = KeyCode.UpArrow;
        //public KeyCode decelerationKey = KeyCode.DownArrow;
    // Balle - Côtés
        //public float distanceFromCenter;
        //public KeyCode moveLeftKey = KeyCode.LeftArrow;
        //public KeyCode moveRightKey = KeyCode.RightArrow;
    // CAMERA
        //public GameObject camera;
    public float percentageView = 0.05f;
    // SIDES
    public bool regeneratesSides;
    private GameObject orientation;
    // MESH
    public GameObject meshCylinder;
    public GameObject mesh;
    public Vector3 meshFactor = new Vector3(1, 1, 1);
    // RESPAWN
    public List<float> respawns = new List<float>();
    public int nextCheckpoint = 0;
    // CIRCLE
    public float circleWidth = 3.0f;
    public float circleAngle = 0.0f;


	// Use this for initialization
    void Start()
    {
        // Style pour l'affichage des infos
        style = new GUIStyle();
        style.fontStyle = FontStyle.Bold;
        style.normal.textColor = couleur;

        // Correction du vieux bug
        OnDrawGizmos();
        percentage = 0.0f;

        // Placement balle
        PutOnPath(balle, positions, percentage);
        PutOnPath(balleRigidBody.gameObject, positions, percentage);
        balleRigidBody.AddForce(Vector3.zero, ForceMode.Impulse);       // TROUVER UNE AUTRE SOLUTION ? -- TEST
        vitesse = vitesses.y;
	}

    void Update()
    {
        // Orientation
        balle.transform.LookAt(PointOnPath(positions, percentage + percentageView));     

        if (nodes.Count >= 4)
        {
            // Update de la vitesse
            if (autoMove)
            {
                if (percentage < 1.0f)
                {
                    percentage += setSpeed(vitesse) * Time.deltaTime;
                    // RESPAWNS
                    if ((respawns.Count > nextCheckpoint) && (percentage > respawns[nextCheckpoint]))
                        nextCheckpoint += 1;
                }
                else
                    percentage = 1.0f;
            }


            // Placement balle
            PutOnPath(balle, positions, percentage);
            //Vector3 start = balle.transform.position;
            //Vector3 end = PointOnPath(positions, percentage);
            //balle.transform.position = Vector3.Lerp(start, end, Time.deltaTime);
        }
    }

    void OnGUI()
    {
        // Slider
        percentage = GUI.VerticalSlider(new Rect(Screen.width - 20, 20, 15, Screen.height - 40), percentage, 1, 0);
    }

    void OnDrawGizmos()
    {
        // Modification du nombre de nodes
        ModifyNodes();

        // Update des positions
        NodesToArrayOfVector3();

        if (nodes.Count >= 4)
        {
            //DrawLineHelper(positions, Color.red, "gizmos");
            DrawPathHelper(positions, couleur, "gizmos");
            if(mesh == null)
                DrawPathMesh(positions, Color.red, "gizmos");
        }

        // GUI
            //DrawEditorGUI();

        // RESPAWNS
        for (int i = 0; i < respawns.Count; i++)
            Gizmos.DrawWireSphere(PointOnPath(positions, respawns[i]), 20.0f);

        // Sides
        if (regeneratesSides)
        {
            regeneratesSides = false;
            GeneratedSides();
        }

        // PAUSE
        if (Time.timeScale == 0.0f)
        {
            if (Input.GetKey(KeyCode.Space))
                Pause(false);
        }

        // Rotation de la balle
            //Gizmos.DrawSphere(PointOnPath(positions, percentage + percentageView/5), meshFactor.magnitude /5);

        if (Input.GetKey(KeyCode.LeftArrow))
        {
            circleAngle = (circleAngle - Time.deltaTime * 64.0f) % 360.0f;
        }
        else if (Input.GetKey(KeyCode.RightArrow))
        {
            circleAngle = (circleAngle + Time.deltaTime*64.0f) % 360.0f;
        }

        Vector3 targetPos = PointOnCircle(meshFactor.magnitude/5,
                                            circleAngle,
                                            (PointOnPath(positions, percentage+(percentageView/4))));
        Gizmos.DrawSphere(targetPos, 0.2f);

        /*
        Gizmos.DrawLine(PointOnCircle(meshFactor.magnitude / 5,
                                            0,
                                            (PointOnPath(positions, percentage + (percentageView / 4)))), PointOnCircle(meshFactor.magnitude / 5,
                                            180,
                                            (PointOnPath(positions, percentage + (percentageView / 4))))
                                            );
         */
        // PUT BALL ONTO THE CIRCLE
        balleRigidBody.transform.position = PointOnCircle(meshFactor.magnitude / 5,
                                            circleAngle,
                                            (PointOnPath(positions, percentage)));

        DrawGizmosMiddleofcircle();
    }

#region CIRCLE
    public static Vector3 PointOnCircle(float radius, float angleInDegrees, Vector3 origin)
    {
        // Convert from degrees to radians via multiplication by PI/180        
        float x = (float)(radius * Mathf.Cos(angleInDegrees * Mathf.PI / 180F)) + origin.x;
        float y = (float)(radius * Mathf.Sin(angleInDegrees * Mathf.PI / 180F)) + origin.y;
            //float z = (float)(radius * Mathf.Cos(angleInDegrees * Mathf.PI / 180F)) + origin.z;
        return new Vector3(x, y, origin.z);
    }

    public void DrawGizmosMiddleofcircle()
    {
        float i=0.0f;

        while(i<1.0f)
        {
            Gizmos.DrawLine(PointOnCircle(meshFactor.magnitude / 5,
                                           0,
                                           (PointOnPath(positions, i))),
                            PointOnCircle(meshFactor.magnitude / 5,
                                           180,
                                           (PointOnPath(positions, i)))
                                           );
            i = i + 0.0005f;
        }
    }
#endregion

    #region RESPAWN
    public void Respawn()
    {
        if (nextCheckpoint == 0)
        {
            percentage = 0.0f;
        }
        else
        {
            percentage = respawns[nextCheckpoint - 1];
        }

        // Placement balle
        PutOnPath(balle, positions, percentage);
        PutOnPath(balleRigidBody.gameObject, positions, percentage);
        balleRigidBody.AddForce(Vector3.zero, ForceMode.Impulse);       // TROUVER UNE AUTRE SOLUTION ? -- TEST
        vitesse = vitesses.y;
        Pause(true);
    }
    #endregion

#region Pause
    public void Pause(bool state)
    {
        if (!state)
        {
            Time.timeScale = 1.0F;
        }
        else
        {
            Time.timeScale = 0.0F;
        }
    }
#endregion

    #region PATH
    #region Autogénération
    void ModifyNodes()   //// TEST -> A AMELIORER
    {
        if (nodeCount > nodes.Count)
        {
            int difference = nodeCount - nodes.Count;

            for (int i = 0; i < difference; i++)
            {
                if (nodes.Count > 0)
                    nodes.Add(GenerateNode(nodes[nodes.Count - 1].transform.position, nodes.Count));
                else
                    nodes.Add(GenerateNode(this.transform.position, nodes.Count));
            }
        }
        else if (nodeCount < nodes.Count)
        {
            int difference = nodes.Count - nodeCount;

            for (int i = 0; i < difference; i++)
            {
                GameObject go = nodes[nodes.Count - 1];
                nodes.RemoveAt(nodes.Count - 1);
                GameObject.DestroyImmediate(go);
            }
        }
    }

    GameObject GenerateNode(Vector3 tPosition, int numero)
    {
        GameObject node = new GameObject();
        node.transform.position = tPosition;
        node.transform.parent = this.transform; // Make child

        node.name = numero.ToString();

        return node;
    }

    void NodesToArrayOfVector3()
    {
        List<Vector3> ligne = new List<Vector3>();

        for (int i = 0; i < nodes.Count; i++)
        {
            ligne.Add(nodes[i].transform.position);
        }

        positions = ligne.ToArray();
    }
        #endregion

        #region Courbe
        private /*static*/ void DrawLineHelper(Vector3[] line, Color color, string method)
    {
        Gizmos.color = color;
        for (int i = 0; i < line.Length - 1; i++)
        {
            if (method == "gizmos")
            {
                Gizmos.DrawLine(line[i], line[i + 1]); ;
            }
            else if (method == "handles")
            {
                Debug.LogError("iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
                //UnityEditor.Handles.DrawLine(line[i], line[i+1]);
            }
        }
    }

        private void DrawPathHelper(Vector3[] path, Color color, string method)
        {
            Vector3[] vector3s = PathControlPointGenerator(path);

            //Line Draw:
            Vector3 prevPt = Interp(vector3s, 0);
            Gizmos.color = color;
            int SmoothAmount = path.Length * 20;
            for (int i = 1; i <= SmoothAmount; i++)
            {
                float pm = (float)i / SmoothAmount;
                Vector3 currPt = Interp(vector3s, pm);
                Gizmos.DrawLine(currPt, prevPt);
                prevPt = currPt;
            }
        }

        private void DrawPathMesh(Vector3[] path, Color color, string method)
        {
            GameObject cylinder;
            // Destroy du mesh précédent
            if (mesh != null)
                DestroyImmediate(mesh);
            mesh = new GameObject();
            mesh.name = "MESH";
            mesh.transform.parent = this.transform;
            mesh.transform.localPosition = new Vector3(0, 0, 0);

            // Génération du Path
            Vector3[] vector3s = PathControlPointGenerator(path);

            //Line Draw:
            Vector3 prevPt = Interp(vector3s, 0);
            Gizmos.color = color;
            int SmoothAmount = path.Length * 20;
            for (int i = 1; i <= SmoothAmount; i++)
            {
                float pm = (float)i / SmoothAmount;
                Vector3 currPt = Interp(vector3s, pm);
                ///////////////////////////////
                // -- Draw du mesh
                    float width = 1.0f;
                    Vector3 offset = currPt - prevPt;
                    Vector3 scale = new Vector3(width * meshFactor.x, (offset.magnitude / 2.0f) * meshFactor.y, width * meshFactor.z);
                    Vector3 pos = prevPt + (offset / 2.0f);
                    // Instantiation du mesh repère
                    cylinder = Instantiate(meshCylinder, pos, Quaternion.identity) as GameObject;
                    // Placement & orientation
                    cylinder.transform.up = offset;
                    // Redimensionnement
                    cylinder.transform.localScale = scale;
                    // Placement dans le GameObject parent
                    cylinder.transform.parent = mesh.transform;
                    // Renommage
                    cylinder.name = (i-1).ToString();
                ///////////////////////////////
                // -- Draw du mesh
                prevPt = currPt;
            }
        }

        private static Vector3[] PathControlPointGenerator(Vector3[] path)
        {
            Vector3[] suppliedPath;
            Vector3[] vector3s;

            //create and store path points:
            suppliedPath = path;

            if (path.Length >= 4)    // ERAILE
            {
                //populate calculate path;
                int offset = 2;
                vector3s = new Vector3[suppliedPath.Length + offset];
                System.Array.Copy(suppliedPath, 0, vector3s, 1, suppliedPath.Length);

                //populate start and end control points:
                //vector3s[0] = vector3s[1] - vector3s[2];
                vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
                vector3s[vector3s.Length - 1] = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);

                //is this a closed, continuous loop? yes? well then so let's make a continuous Catmull-Rom spline!
                if (vector3s[1] == vector3s[vector3s.Length - 2])
                {
                    Vector3[] tmpLoopSpline = new Vector3[vector3s.Length];
                    System.Array.Copy(vector3s, tmpLoopSpline, vector3s.Length);
                    tmpLoopSpline[0] = tmpLoopSpline[tmpLoopSpline.Length - 3];
                    tmpLoopSpline[tmpLoopSpline.Length - 1] = tmpLoopSpline[2];
                    vector3s = new Vector3[tmpLoopSpline.Length];
                    System.Array.Copy(tmpLoopSpline, vector3s, tmpLoopSpline.Length);
                }

                return (vector3s);
            }

            return null;
        }

        private Vector3 Interp(Vector3[] pts, float t)
        {
            if (pts != null && pts.Length >= 4)        // ERAILE
            {
                int numSections = pts.Length - 3;
                int currPt = Mathf.Min(Mathf.FloorToInt(t * (float)numSections), numSections - 1);
                float u = t * (float)numSections - (float)currPt;

                Vector3 a = pts[currPt];
                Vector3 b = pts[currPt + 1];
                Vector3 c = pts[currPt + 2];
                Vector3 d = pts[currPt + 3];

                return .5f * (
                    (-a + 3f * b - 3f * c + d) * (u * u * u)
                    + (2f * a - 5f * b + 4f * c - d) * (u * u)
                    + (-a + c) * u
                    + 2f * b
                );
            }

            return Vector3.zero;
    }

        public void PutOnPath(GameObject target, Vector3[] path, float percent)
    {
        target.transform.position = Interp(PathControlPointGenerator(path), percent);
    }

        public Vector3 PointOnPath(Vector3[] path, float percent)
    {
        return (Interp(PathControlPointGenerator(path), percent));
    }

        public float PathLength(Vector3[] path)
    {
        float pathLength = 0;

        Vector3[] vector3s = PathControlPointGenerator(path);

        //Line Draw:
        Vector3 prevPt = Interp(vector3s, 0);
        int SmoothAmount = path.Length * 20;
        for (int i = 1; i <= SmoothAmount; i++)
        {
            float pm = (float)i / SmoothAmount;
            Vector3 currPt = Interp(vector3s, pm);
            pathLength += Vector3.Distance(prevPt, currPt);
            prevPt = currPt;
        }

        return pathLength;
    }	

        public void DrawEditorGUI()
        {
            /// OK
            if (nodes.Count >= 4)
            {
                //path begin and end labels:
                Handles.Label(nodes[0].transform.position, 
                    "Debut", style);
                Handles.Label(nodes[nodes.Count - 1].transform.position,
                    "Fin", style);

                // Path lenght label on middle
                Handles.Label(PointOnPath(positions, 0.5f), "Longueur = "+ PathLength(positions).ToString() +"m", style);
            }
        }
        #endregion
    #endregion

        #region PathSides
        void GeneratedSides()
        {
            GameObject node;
            List<GameObject> newNodes = new List<GameObject>();


            // Side
            if(orientation != null)
                DestroyImmediate(orientation);
            orientation = new GameObject("Orientation");
            orientation.transform.parent = transform;
            orientation.transform.position = new Vector3(0, 0, 0);
            // Curve attribute
            Curve curve = orientation.AddComponent<Curve>();
            newNodes = new List<GameObject>();
            for (int i = 0; i < nodes.Count; i++)
            {
                node = new GameObject();
                node.name = i.ToString();
                node.transform.parent = orientation.transform;
                node.transform.position = nodes[i].transform.position;
                newNodes.Add(node);
            }
            curve.ResetNodes(newNodes);

           // orientation.transform.localPosition = new Vector3(  orientation.transform.localPosition.x,
           //                                                     orientation.transform.localPosition.y + 20.0f,
           //                                                     orientation.transform.localPosition.z);
        }
        #endregion

        #region Balle
        #region Vitesse
        public float setSpeed(float kmHour)
        {
            // UPDATE DE LA SPEED
            if (Input.GetKey(KeyAcceleration))
            {
                if (vitesse < vitesses.z)
                    vitesse += acceleration * Time.deltaTime;
                else
                    vitesse = vitesses.z;
            }
            else if(Input.GetKey(KeyDeceleration))
            {
                if (vitesse > vitesses.x)
                    vitesse -= acceleration * Time.deltaTime;
                else
                    vitesse = vitesses.x;
            }
            else
            {
                if(vitesse > vitesses.y)
                {
                    vitesse -= acceleration * Time.deltaTime;
                    if(vitesse < vitesses.y)
                        vitesse = vitesses.y;
                }
                else if(vitesse < vitesses.y)
                {
                    vitesse += acceleration * Time.deltaTime;
                    if(vitesse > vitesses.y)
                        vitesse = vitesses.y;
                }
            }



            // TRANSFORMATION EN KM/H
            float speedMpS = kmHour * 0.277778f;

		    if ( nodes.Count >= 4)
			    return ( speedMpS / PathLength( positions ) );
		    else
			    return 0.0f;         
        }
        #endregion
    #endregion
}
